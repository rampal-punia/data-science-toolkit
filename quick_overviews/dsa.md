## Algorithms & DSA

Here’s a list of Important keywords related to algorithms and data structures in Python programming, along with their brief definitions:

### **1. Array**
- **Definition**: A data structure that stores elements of the same type in contiguous memory locations, accessible via indices.

### **2. Linked List**
- **Definition**: A linear data structure where elements (nodes) are connected using pointers, with each node containing data and a reference to the next node.

### **3. Stack**
- **Definition**: A linear data structure following Last In, First Out (LIFO) order, where elements are added and removed from the same end (top).

### **4. Queue**
- **Definition**: A linear data structure following First In, First Out (FIFO) order, where elements are added at the rear and removed from the front.

### **5. Binary Tree**
- **Definition**: A hierarchical data structure in which each node has at most two children, commonly referred to as the left child and right child.

### **6. Binary Search Tree (BST)**
- **Definition**: A binary tree in which each node’s left subtree contains values less than the node, and the right subtree contains values greater than the node.

### **7. Heap**
- **Definition**: A complete binary tree that satisfies the heap property, where the key at the root must be either the maximum (max-heap) or minimum (min-heap) among all keys.

### **8. Hash Table**
- **Definition**: A data structure that maps keys to values for efficient lookup, using a hash function to compute an index into an array of buckets.

### **9. Graph**
- **Definition**: A collection of nodes (vertices) and edges (connections between nodes) that can represent various real-world problems like networks and relationships.

### **10. Breadth-First Search (BFS)**
- **Definition**: An algorithm for traversing or searching tree or graph data structures, starting from the root node and exploring neighbor nodes level by level.

### **11. Depth-First Search (DFS)**
- **Definition**: An algorithm for traversing or searching tree or graph data structures, starting from the root and exploring as far as possible along each branch before backtracking.

### **12. Dijkstra's Algorithm**
- **Definition**: An algorithm for finding the shortest paths between nodes in a graph, particularly from a single source node to all other nodes.

### **13. Merge Sort**
- **Definition**: A divide-and-conquer algorithm that divides the input array into two halves, recursively sorts them, and then merges the sorted halves.

### **14. Quick Sort**
- **Definition**: A divide-and-conquer algorithm that picks a pivot element and partitions the array into two parts, recursively sorting each part.

### **15. Bubble Sort**
- **Definition**: A simple comparison-based sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.

### **16. Insertion Sort**
- **Definition**: A simple sorting algorithm that builds the final sorted array one item at a time, inserting each new element into its correct position.

### **17. Selection Sort**
- **Definition**: A comparison-based sorting algorithm that divides the array into a sorted and unsorted part, repeatedly selecting the smallest element from the unsorted part and moving it to the sorted part.

### **18. Radix Sort**
- **Definition**: A non-comparative integer sorting algorithm that sorts numbers by processing individual digits, starting from the least significant to the most significant.

### **19. Counting Sort**
- **Definition**: A non-comparison-based sorting algorithm that counts the occurrences of each distinct element and uses this count to determine the position of each element in the output array.

### **20. Bucket Sort**
- **Definition**: A distribution-based sorting algorithm that distributes elements into buckets and then sorts each bucket individually before combining them.

### **21. AVL Tree**
- **Definition**: A self-balancing binary search tree where the difference between the heights of left and right subtrees cannot be more than one for all nodes.

### **22. Red-Black Tree**
- **Definition**: A self-balancing binary search tree where each node has an additional color attribute (red or black) to ensure the tree remains approximately balanced during insertions and deletions.

### **23. Trie**
- **Definition**: A tree-like data structure that stores a dynamic set of strings, often used for searching strings in a dictionary.

### **24. Dynamic Programming**
- **Definition**: An algorithmic technique that solves complex problems by breaking them down into simpler subproblems and solving each subproblem only once, storing the results for future use.

### **25. Greedy Algorithm**
- **Definition**: An algorithm that makes the locally optimal choice at each step, aiming for a global optimum, often used for optimization problems.

### **26. Divide and Conquer**
- **Definition**: An algorithm design paradigm that divides the problem into smaller subproblems, solves them independently, and then combines the solutions.

### **27. Backtracking**
- **Definition**: An algorithmic technique for solving problems incrementally by trying partial solutions and abandoning them if they are not suitable.

### **28. Knapsack Problem**
- **Definition**: An optimization problem where the goal is to maximize the total value of items placed in a knapsack without exceeding its capacity, solvable using dynamic programming or greedy approaches.

### **29. Floyd-Warshall Algorithm**
- **Definition**: An algorithm for finding shortest paths between all pairs of vertices in a graph, particularly useful for dense graphs.

### **30. Prim’s Algorithm**
- **Definition**: An algorithm for finding a minimum spanning tree in a weighted graph, starting from an arbitrary vertex and growing the tree one edge at a time.

### **31. Kruskal’s Algorithm**
- **Definition**: An algorithm for finding a minimum spanning tree in a weighted graph by sorting all edges by weight and adding them to the tree if they don’t form a cycle.

### **32. Bellman-Ford Algorithm**
- **Definition**: An algorithm for finding the shortest paths from a single source vertex to all other vertices in a weighted graph, capable of handling graphs with negative weights.

### **33. Binary Search**
- **Definition**: A search algorithm that finds the position of a target value within a sorted array by repeatedly dividing the search interval in half.

### **34. Hashing**
- **Definition**: A technique for converting a range of key values into a range of indexes of an array, used for fast data retrieval.

### **35. LRU Cache**
- **Definition**: A data structure that removes the least recently used items first when it exceeds its size limit, often implemented with a hash map and doubly linked list.

### **36. Floyd’s Cycle Detection**
- **Definition**: An algorithm for detecting cycles in a sequence of iterated function values, commonly used to detect loops in linked lists.

### **37. Segment Tree**
- **Definition**: A data structure that allows efficient range queries and updates, commonly used for answering sum, minimum, or maximum queries on an array.

### **38. Fenwick Tree (Binary Indexed Tree)**
- **Definition**: A data structure that provides efficient methods for cumulative frequency tables, used for performing range sum queries and updates.

### **39. Topological Sorting**
- **Definition**: A linear ordering of vertices in a directed acyclic graph, where for every directed edge `uv`, vertex `u` comes before `v` in the ordering.

### **40. B-Tree**
- **Definition**: A self-balancing tree data structure that maintains sorted data and allows for efficient insertion, deletion, and search operations, commonly used in databases and file systems.

### **41. Splay Tree**
- **Definition**: A self-adjusting binary search tree where recently accessed elements are moved to the root, ensuring that frequently accessed elements are quick to access.

### **42. Union-Find**
- **Definition**: A data structure that keeps track of elements partitioned into disjoint sets, supporting union and find operations, commonly used in network connectivity and image processing.

### **43. Bloom Filter**
- **Definition**: A space-efficient probabilistic data structure used to test whether an element is a member of a set, with false positive matches but no false negatives.

### **44. KMP Algorithm**
- **Definition**: The Knuth-Morris-Pratt algorithm for string matching, which preprocesses the pattern to find matches in linear time.

### **45. Rabin-Karp Algorithm**
- **Definition**: A string matching algorithm that uses hashing to find any one of a set of pattern strings in a text, with a focus on reducing hash collisions.

### **46. Boyer-Moore Algorithm**
- **Definition**: An efficient string searching algorithm that skips sections of the text, based on information gathered during the matching process, leading to faster search times.

### **47. A* Algorithm**
- **Definition**: A graph traversal and pathfinding algorithm that finds the shortest path from a start node to a target node, using heuristics to optimize the search.

### **48. Timsort**
- **Definition**: A hybrid sorting algorithm derived from merge sort and insertion sort, optimized for real-world data, and used as the default sorting algorithm in Python.

### **49. Cartesian Tree**
- **Definition**: A binary tree derived from a sequence of numbers, where each node corresponds to the smallest (or largest) value in a subsequence, used in range queries.

### **50. Z-Algorithm**
- **Definition**: An algorithm that finds all occurrences of a pattern in a text in linear time by computing the Z-array, which contains the lengths of substrings that match the prefix
